<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Draw Pattern</title>
  <style>
    /* --- RESET & LAYOUT --- */
    html, body {
      margin: 0; padding: 0; width: 100%; height: 100%;
      font-family: system-ui, -apple-system, sans-serif;
      overflow: hidden; background: #111; color: white;
    }
    
    .step {
      position: absolute; inset: 0;
      display: flex; flex-direction: column;
      transition: transform 0.4s ease;
      background: #111;
    }
    .hidden-left { transform: translateX(-100%); }
    .hidden-right { transform: translateX(100%); }

    /* --- STEP 1: DRAW --- */
    #draw-container {
      flex: 1; position: relative;
      background: #222; 
      touch-action: none; cursor: crosshair;
      overflow: hidden;
    }
    canvas { display: block; }

    /* --- STEP 2: PREVIEW --- */
    #preview-container {
      flex: 1; position: relative;
      background: #000;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
    }
    #previewCanvas { width: 100%; height: 100%; object-fit: cover; }

    /* --- UI BARS --- */
    .ui-bar {
      z-index: 10;
      background: rgba(0,0,0,0.85);
      backdrop-filter: blur(10px);
      padding: 12px;
      display: flex; gap: 10px;
      align-items: center; justify-content: space-between;
      border-top: 1px solid rgba(255,255,255,0.15);
    }
    .top-bar {
      border-bottom: 1px solid rgba(255,255,255,0.15);
      border-top: none;
      justify-content: center;
    }
    h2 { margin: 0; font-size: 16px; font-weight: 600; letter-spacing: 0.5px; opacity: 0.9; }

    /* CONTROLS */
    .btn {
      background: #eee; color: #111; border: none;
      padding: 10px 16px; border-radius: 20px;
      font-weight: 600; font-size: 14px; cursor: pointer; white-space: nowrap;
    }
    .btn:active { transform: scale(0.96); }
    .btn-icon { padding: 10px; border-radius: 50%; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center;}

    .control-group { display: flex; flex-direction: column; gap: 2px; }
    label { font-size: 10px; text-transform: uppercase; color: #aaa; letter-spacing: 0.5px; }
    
    select, input[type="color"] {
      background: #333; border: 1px solid #555;
      color: white; padding: 0 4px; border-radius: 6px;
      font-size: 14px; height: 32px; outline: none;
    }
    input[type="color"] { width: 40px; padding: 2px; }
    
    #imgUpload { display: none; }
  </style>
</head>
<body>

  <div id="step1" class="step">
    <div class="ui-bar top-bar">
      <h2>1. Create Tile</h2>
    </div>

    <div id="draw-container">
      <canvas id="drawCanvas"></canvas>
    </div>

    <div class="ui-bar">
      <div class="control-group">
        <label>Color</label>
        <input type="color" id="brushColor" value="#ffffff">
      </div>

      <div class="control-group">
        <label>Image</label>
        <button class="btn btn-icon" id="uploadBtn" style="background:#444; color:white;">
          ðŸ“‚
        </button>
        <input type="file" id="imgUpload" accept="image/*">
      </div>

      <div style="flex:1"></div>
      
      <button class="btn" id="clearBtn" style="background:transparent; border:1px solid #666; color:#ccc; margin-right:8px;">Clear</button>
      <button class="btn" id="toStep2">Next &rarr;</button>
    </div>
  </div>

  <div id="step2" class="step hidden-right">
    <div class="ui-bar top-bar">
      <h2>2. Style Pattern</h2>
    </div>

    <div id="preview-container">
      <canvas id="previewCanvas"></canvas>
    </div>

    <div class="ui-bar" style="flex-wrap: wrap;">
      <div class="control-group">
        <label>Background</label>
        <input type="color" id="bgColor" value="#000000">
      </div>

      <div class="control-group" style="flex:1">
        <label>Pattern Style</label>
        <select id="tileMode" style="width:100%">
          <option value="grid">Grid</option>
          <option value="brick">Brick (Offset)</option>
          <option value="hex">Hex (Packed)</option>
        </select>
      </div>

      <div style="width: 100%; height: 8px;"></div>

      <button class="btn" id="backBtn" style="background:transparent; border:1px solid #666; color:#ccc;">&larr; Edit</button>
      <div style="flex:1"></div>
      <button class="btn" id="saveBtn">View in AR &rarr;</button>
    </div>
  </div>

  <script>
    // --- VARIABLES ---
    const drawCanvas = document.getElementById("drawCanvas");
    const ctx = drawCanvas.getContext("2d");
    const previewCanvas = document.getElementById("previewCanvas");
    const pctx = previewCanvas.getContext("2d");

    let isDrawing = false;
    let lastX = 0; let lastY = 0;

    // --- 1. SETUP CANVAS ---
    function resizeDrawCanvas() {
      const container = document.getElementById("draw-container");
      // Only resize if dimensions actually changed
      if (drawCanvas.width !== container.clientWidth || drawCanvas.height !== container.clientHeight) {
        const saved = drawCanvas.toDataURL();
        drawCanvas.width = container.clientWidth;
        drawCanvas.height = container.clientHeight;
        
        ctx.lineWidth = 12;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = document.getElementById("brushColor").value;

        const img = new Image();
        img.onload = () => ctx.drawImage(img, 0, 0);
        img.src = saved;
      }
    }
    window.addEventListener("resize", resizeDrawCanvas);
    setTimeout(resizeDrawCanvas, 10); // Init

    document.getElementById("brushColor").addEventListener("input", (e) => {
      ctx.strokeStyle = e.target.value;
    });

    // --- 2. DRAWING INPUT ---
    function startDraw(e) {
      isDrawing = true;
      const { x, y } = getPos(e);
      lastX = x; lastY = y;
    }
    function draw(e) {
      if (!isDrawing) return;
      e.preventDefault(); 
      const { x, y } = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(x, y);
      ctx.stroke();
      lastX = x; lastY = y;
    }
    function endDraw() { isDrawing = false; }
    
    function getPos(e) {
      const rect = drawCanvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      return { x: clientX - rect.left, y: clientY - rect.top };
    }

    drawCanvas.addEventListener("mousedown", startDraw);
    drawCanvas.addEventListener("mousemove", draw);
    drawCanvas.addEventListener("mouseup", endDraw);
    drawCanvas.addEventListener("touchstart", startDraw, { passive: false });
    drawCanvas.addEventListener("touchmove", draw, { passive: false });
    drawCanvas.addEventListener("touchend", endDraw);

    document.getElementById("clearBtn").addEventListener("click", () => {
      ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    });

    // --- 3. UPLOAD IMAGE (FILL/COVER MODE) ---
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("imgUpload");

    uploadBtn.addEventListener("click", () => fileInput.click());

    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          // Logic to FILL (Cover) the canvas
          const canvasRatio = drawCanvas.width / drawCanvas.height;
          const imgRatio = img.width / img.height;
          
          let drawW, drawH, drawX, drawY;

          if (imgRatio > canvasRatio) {
            // Image is wider than canvas: crop sides
            drawH = drawCanvas.height;
            drawW = drawCanvas.height * imgRatio;
            drawX = (drawCanvas.width - drawW) / 2;
            drawY = 0;
          } else {
            // Image is taller than canvas: crop top/bottom
            drawW = drawCanvas.width;
            drawH = drawCanvas.width / imgRatio;
            drawX = 0;
            drawY = (drawCanvas.height - drawH) / 2;
          }

          ctx.drawImage(img, drawX, drawY, drawW, drawH);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    // --- 4. NAVIGATION ---
    const step1 = document.getElementById("step1");
    const step2 = document.getElementById("step2");

    document.getElementById("toStep2").addEventListener("click", () => {
      renderPatternPreview(); 
      step1.classList.add("hidden-left");
      step2.classList.remove("hidden-right");
    });

    document.getElementById("backBtn").addEventListener("click", () => {
      step2.classList.add("hidden-right");
      step1.classList.remove("hidden-left");
    });

    // --- 5. PREVIEW GENERATION (NO STRETCH) ---
    const bgColorInput = document.getElementById("bgColor");
    const tileModeInput = document.getElementById("tileMode");

    bgColorInput.addEventListener("input", renderPatternPreview);
    tileModeInput.addEventListener("change", renderPatternPreview);

    function renderPatternPreview() {
      const container = document.getElementById("preview-container");
      previewCanvas.width = container.clientWidth;
      previewCanvas.height = container.clientHeight;

      // Fill BG
      pctx.fillStyle = bgColorInput.value;
      pctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);

      // --- CALCULATE TILE SIZE RESPECTING ASPECT RATIO ---
      // We set a fixed Base Size (e.g. width = 120px)
      // Then we calculate Height based on the Drawing Canvas ratio
      const baseSize = 120; 
      const ratio = drawCanvas.width / drawCanvas.height;
      
      const tileW = baseSize;
      const tileH = baseSize / ratio; 

      const mode = tileModeInput.value;
      const cols = Math.ceil(previewCanvas.width / tileW) + 1;
      const rows = Math.ceil(previewCanvas.height / tileH) + 1;

      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          let dx = x * tileW;
          let dy = y * tileH;

          if (mode === 'brick') {
            if (y % 2 === 1) dx -= tileW / 2;
          } else if (mode === 'hex') {
            dy = y * (tileH * 0.85); // Vertical overlap
            if (y % 2 === 1) dx -= tileW / 2;
          }

          pctx.drawImage(drawCanvas, dx, dy, tileW, tileH);
        }
      }
    }

    // --- 6. SAVE (HIGH RES, NO STRETCH) ---
    document.getElementById("saveBtn").addEventListener("click", () => {
      const texCanvas = document.createElement("canvas");
      texCanvas.width = 1024;
      texCanvas.height = 1024;
      const tctx = texCanvas.getContext("2d");

      tctx.fillStyle = bgColorInput.value;
      tctx.fillRect(0, 0, 1024, 1024);

      // Same Aspect Ratio Logic for the Texture
      // We want about 6 columns across the texture
      const REPEAT_COLS = 6; 
      const tileW = 1024 / REPEAT_COLS; 
      const ratio = drawCanvas.width / drawCanvas.height;
      const tileH = tileW / ratio;

      // Calculate how many rows needed to fill 1024 height
      const REPEAT_ROWS = Math.ceil(1024 / tileH);
      const mode = tileModeInput.value;

      // Draw with buffer
      for (let y = -1; y < REPEAT_ROWS + 2; y++) {
        for (let x = -1; x < REPEAT_COLS + 2; x++) {
          let dx = x * tileW;
          let dy = y * tileH;

          if (mode === 'brick') {
            if (y % 2 === 1) dx -= tileW / 2;
          } else if (mode === 'hex') {
            dy = y * (tileH * 0.85);
            if (y % 2 === 1) dx -= tileW / 2;
          }

          tctx.drawImage(drawCanvas, dx, dy, tileW, tileH);
        }
      }

      localStorage.setItem("pattern_png", texCanvas.toDataURL("image/png"));
      location.href = "ar.html";
    });

  </script>
</body>
</html>