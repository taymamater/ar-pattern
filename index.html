<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Pattern Maker</title>

  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto; }
    .topbar{
      position: fixed; top: 12px; left: 12px; right: 12px;
      z-index: 20;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      color: rgba(255,255,255,.92);
      background: rgba(0,0,0,.45);
      padding: 10px 12px; border-radius: 14px;
      backdrop-filter: blur(8px);
    }
    .topbar small{ opacity:.85; display:block; margin-top:2px; }
    .panel{
      position: fixed; left: 0; right: 0; bottom: 0;
      z-index: 20;
      background: linear-gradient(to top, rgba(0,0,0,.78), rgba(0,0,0,0));
      padding: 12px 12px calc(14px + env(safe-area-inset-bottom));
      display:grid;
      gap: 10px;
    }
    .row{ display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap; }
    .btn{
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.25);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      user-select:none;
      font-size: 14px;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{ background: rgba(255,255,255,.22); }
    .chip{
      display:flex; align-items:center; gap:8px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.22);
      padding: 8px 10px; border-radius: 999px;
      color: rgba(255,255,255,.92);
      font-size: 14px;
    }
    input[type="color"]{ width: 34px; height: 34px; border: none; background: transparent; padding: 0; }
    select{
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.25);
      color: rgba(255,255,255,.92);
      padding: 8px 10px;
      border-radius: 12px;
      font-size: 14px;
      outline: none;
    }
    .wrap{ display:flex; justify-content:center; }
    canvas.box{
      width: min(86vw, 340px);
      height: min(86vw, 340px);
      border-radius: 16px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.20);
      touch-action: none;
    }
    .hint{ text-align:center; color: rgba(255,255,255,.85); font-size: 13px; }
    .grid2{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
      justify-items:center;
    }
    @media (min-width: 700px){
      .grid2{ grid-template-columns: 1fr 1fr; align-items:start; }
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div>
      <div><strong>Pattern Maker</strong></div>
      <small id="status">Step 1: Draw (freehand) → Next to convert into a grid.</small>
    </div>
    <div class="chip">
      Grid
      <select id="gridSize">
        <option value="8">8×8</option>
        <option value="16" selected>16×16</option>
        <option value="24">24×24</option>
      </select>
    </div>
  </div>

  <!-- STEP 1: draw -->
  <div class="panel" id="step1">
    <div class="wrap">
      <canvas id="drawCanvas" class="box" width="340" height="340"></canvas>
    </div>

    <div class="row">
      <div class="chip">Color <input id="color" type="color" value="#ff6a00" /></div>
      <div class="chip">
        Size
        <select id="brushSize">
          <option value="6">6</option>
          <option value="10" selected>10</option>
          <option value="16">16</option>
          <option value="24">24</option>
        </select>
      </div>
      <div class="btn" id="eraser">Eraser</div>
      <div class="btn" id="clearDraw">Clear</div>
      <label class="btn" for="importImg">Import AI Image</label>
      <input id="importImg" type="file" accept="image/*" hidden />
      <div class="btn primary" id="toGrid">Next → Grid</div>
    </div>

    <div class="hint">
      Tip: You can draw freely, or import an AI image, then convert it into a pixel grid.
    </div>
  </div>

  <!-- STEP 2: grid + preview -->
  <div class="panel" id="step2" style="display:none">
    <div class="grid2">
      <div>
        <div class="hint" style="margin-bottom:6px">Step 2: Your drawing converted to a grid</div>
        <div class="wrap">
          <canvas id="gridCanvas" class="box" width="340" height="340"></canvas>
        </div>
      </div>

      <div>
        <div class="hint" style="margin-bottom:6px">Pattern preview (tiled)</div>
        <div class="wrap">
          <canvas id="previewCanvas" class="box" width="340" height="340"></canvas>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="btn" id="backToDraw">← Back</div>
      <div class="btn" id="exportGrid">Export PNG</div>
      <div class="btn primary" id="openAR">Open AR →</div>
    </div>

    <div class="hint" id="gridHint">If it looks too detailed, switch Grid to 8×8 or 16×16.</div>
  </div>

  <!-- Hidden texture canvas (NxN) -->
  <canvas id="texCanvas" width="16" height="16" style="display:none"></canvas>

  <script>
    const status = document.getElementById("status");

    const step1 = document.getElementById("step1");
    const step2 = document.getElementById("step2");

    const drawCanvas = document.getElementById("drawCanvas");
    const dctx = drawCanvas.getContext("2d");

    const gridCanvas = document.getElementById("gridCanvas");
    const gctx = gridCanvas.getContext("2d");

    const previewCanvas = document.getElementById("previewCanvas");
    const pctx = previewCanvas.getContext("2d");

    const texCanvas = document.getElementById("texCanvas");
    const tctx = texCanvas.getContext("2d");

    const gridSizeSel = document.getElementById("gridSize");
    const colorInput = document.getElementById("color");
    const brushSizeSel = document.getElementById("brushSize");

    let N = parseInt(gridSizeSel.value, 10);
    let drawing = false;
    let isEraser = false;

    // Setup drawing style
    function applyBrush() {
      dctx.lineCap = "round";
      dctx.lineJoin = "round";
      dctx.lineWidth = parseInt(brushSizeSel.value, 10);
      if (isEraser) {
        dctx.globalCompositeOperation = "destination-out";
        dctx.strokeStyle = "rgba(0,0,0,1)";
      } else {
        dctx.globalCompositeOperation = "source-over";
        dctx.strokeStyle = colorInput.value;
      }
    }
    applyBrush();

    function getPos(e) {
      const r = drawCanvas.getBoundingClientRect();
      return { x: (e.clientX - r.left) * (drawCanvas.width / r.width),
               y: (e.clientY - r.top)  * (drawCanvas.height / r.height) };
    }

    drawCanvas.addEventListener("pointerdown", (e) => {
      drawing = true;
      drawCanvas.setPointerCapture(e.pointerId);
      applyBrush();
      const p = getPos(e);
      dctx.beginPath();
      dctx.moveTo(p.x, p.y);
    });

    drawCanvas.addEventListener("pointermove", (e) => {
      if (!drawing) return;
      const p = getPos(e);
      dctx.lineTo(p.x, p.y);
      dctx.stroke();
    });

    drawCanvas.addEventListener("pointerup", () => { drawing = false; });
    drawCanvas.addEventListener("pointercancel", () => { drawing = false; });

    document.getElementById("eraser").addEventListener("click", () => {
      isEraser = !isEraser;
      status.textContent = isEraser ? "Eraser ON (freehand). Tap again to draw." : "Draw mode (freehand).";
      applyBrush();
    });

    document.getElementById("clearDraw").addEventListener("click", () => {
      dctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
      status.textContent = "Cleared. Draw again, then convert to grid.";
    });

    brushSizeSel.addEventListener("change", applyBrush);
    colorInput.addEventListener("change", applyBrush);

    // Import AI image into the draw canvas (cover fit)
    document.getElementById("importImg").addEventListener("change", async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;

      const img = new Image();
      img.src = URL.createObjectURL(file);
      await img.decode();

      const cw = drawCanvas.width, ch = drawCanvas.height;
      const scale = Math.max(cw / img.width, ch / img.height);
      const sw = cw / scale, sh = ch / scale;
      const sx = (img.width - sw) / 2, sy = (img.height - sh) / 2;

      dctx.save();
      dctx.globalCompositeOperation = "source-over";
      dctx.drawImage(img, sx, sy, sw, sh, 0, 0, cw, ch);
      dctx.restore();

      URL.revokeObjectURL(img.src);
      e.target.value = "";
      status.textContent = "Imported image. You can draw on top, then convert to grid.";
    });

    // Convert drawCanvas => NxN texCanvas (pixel grid)
    function convertToGrid() {
      N = parseInt(gridSizeSel.value, 10);
      texCanvas.width = N;
      texCanvas.height = N;

      const off = document.createElement("canvas");
      off.width = N; off.height = N;
      const offCtx = off.getContext("2d");
      offCtx.imageSmoothingEnabled = true;

      // Downsample drawing to NxN
      offCtx.clearRect(0,0,N,N);
      offCtx.drawImage(drawCanvas, 0, 0, N, N);

      // Read pixels and write to texCanvas as crisp pixels
      const data = offCtx.getImageData(0,0,N,N).data;
      const img = tctx.createImageData(N, N);

      for (let i=0; i<N*N; i++){
        const r = data[i*4], g = data[i*4+1], b = data[i*4+2], a = data[i*4+3];
        const base = i*4;

        // Treat near-transparent as empty
        if (a < 20) {
          img.data[base+3] = 0;
          continue;
        }

        img.data[base]   = r;
        img.data[base+1] = g;
        img.data[base+2] = b;
        img.data[base+3] = 255;
      }

      tctx.putImageData(img, 0, 0);
    }

    function renderGridCanvas() {
      const w = gridCanvas.width, h = gridCanvas.height;
      gctx.clearRect(0,0,w,h);

      // background
      gctx.fillStyle = "rgba(255,255,255,0.02)";
      gctx.fillRect(0,0,w,h);

      const cellW = w / N;
      const cellH = h / N;

      const pix = tctx.getImageData(0,0,N,N).data;
      for (let y=0; y<N; y++){
        for (let x=0; x<N; x++){
          const i = (y*N + x) * 4;
          const a = pix[i+3];
          if (a === 0) continue;
          gctx.fillStyle = `rgb(${pix[i]},${pix[i+1]},${pix[i+2]})`;
          gctx.fillRect(x*cellW, y*cellH, cellW, cellH);
        }
      }

      // grid lines
      gctx.strokeStyle = "rgba(255,255,255,0.18)";
      gctx.lineWidth = 1;
      for (let i=0; i<=N; i++){
        gctx.beginPath();
        gctx.moveTo(i*cellW, 0);
        gctx.lineTo(i*cellW, h);
        gctx.stroke();

        gctx.beginPath();
        gctx.moveTo(0, i*cellH);
        gctx.lineTo(w, i*cellH);
        gctx.stroke();
      }
    }

    function renderTiledPreview() {
      const w = previewCanvas.width, h = previewCanvas.height;
      pctx.clearRect(0,0,w,h);

      pctx.fillStyle = "rgba(255,255,255,0.02)";
      pctx.fillRect(0,0,w,h);

      // tile size in screen pixels
      const tilePx = Math.floor(w / 6); // 6 tiles across
      pctx.imageSmoothingEnabled = false;

      // draw texCanvas scaled up, repeated
      for (let y=0; y<h; y += tilePx){
        for (let x=0; x<w; x += tilePx){
          pctx.drawImage(texCanvas, x, y, tilePx, tilePx);
        }
      }
    }

    function showStep2() {
      convertToGrid();
      renderGridCanvas();
      renderTiledPreview();

      step1.style.display = "none";
      step2.style.display = "grid";

      status.textContent = `Step 2: Grid preview (${N}×${N}) → Open AR when ready.`;
    }

    document.getElementById("toGrid").addEventListener("click", showStep2);

    document.getElementById("backToDraw").addEventListener("click", () => {
      step2.style.display = "none";
      step1.style.display = "grid";
      status.textContent = "Step 1: Draw (freehand) → Next to convert into a grid.";
    });

    // If user changes grid size while in step 2, reconvert live
    gridSizeSel.addEventListener("change", () => {
      if (step2.style.display !== "none") {
        showStep2();
      }
    });

    // Export grid texture (scaled up, crisp)
    document.getElementById("exportGrid").addEventListener("click", () => {
      const out = document.createElement("canvas");
      const scale = 40;
      out.width = N * scale;
      out.height = N * scale;
      const octx = out.getContext("2d");
      octx.imageSmoothingEnabled = false;
      octx.drawImage(texCanvas, 0, 0, out.width, out.height);

      const a = document.createElement("a");
      a.download = `pattern_${N}x${N}.png`;
      a.href = out.toDataURL("image/png");
      a.click();
    });

    // Save to localStorage and open AR page
    document.getElementById("openAR").addEventListener("click", () => {
      // store the tiny texture as PNG dataURL
      localStorage.setItem("pattern_png", texCanvas.toDataURL("image/png"));
      localStorage.setItem("pattern_N", String(N));
      window.location.href = "./ar.html";
    });
  </script>
</body>
</html>
